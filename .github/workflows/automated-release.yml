name: Automated Release

# This workflow automatically creates releases based on semantic versioning
# Triggers when PRs are merged to main/develop with specific keywords

# Required permissions for creating releases
permissions:
  contents: write      # Required to create releases (but not push to repo)
  pull-requests: read  # Required to read PR information
  issues: read         # Required to read issue information

on:
  pull_request:
    types: [closed]
    branches: [main, develop]
  workflow_dispatch:
    inputs:
      version_type:
        description: 'Manual release version type'
        required: false
        default: 'patch'
        type: choice
        options:
          - major
          - minor
          - patch
      custom_version:
        description: 'Custom version (e.g., 1.2.3)'
        required: false
        type: string

env:
  PYTHON_VERSION: '3.11.9'

jobs:
  determine-version:
    name: Determine Release Version
    runs-on: ubuntu-latest
    outputs:
      version_type: ${{ steps.version-check.outputs.version_type }}
      current_version: ${{ steps.current-version.outputs.current_version }}
      new_version: ${{ steps.new-version.outputs.new_version }}
      should_release: ${{ steps.version-check.outputs.should_release }}
      release_notes_file: ${{ steps.release-notes.outputs.notes_file }}

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        check-latest: false

    - name: Install dependencies
      run: |
        pip install semver

    - name: Check for release keywords
      id: version-check
      run: |
        python -c "
        import re
        import os

        # Get event content from environment
        event_content = os.environ.get('GITHUB_EVENT_NAME') == 'pull_request' and os.environ.get('GITHUB_EVENT_PATH') and open(os.environ.get('GITHUB_EVENT_PATH')).read() or '{}'

        # Check if this is a manual dispatch
        if os.environ.get('GITHUB_EVENT_NAME') == 'workflow_dispatch':
            version_type = os.environ.get('INPUT_VERSION_TYPE', 'patch')
            print(f'Debug: Manual dispatch detected, version_type={version_type}')
            with open(os.environ['GITHUB_OUTPUT'], 'a') as gh_out:
                gh_out.write(f'version_type={version_type}\n')
                gh_out.write('should_release=true\n')
            exit(0)

        # Check if PR was merged
        if os.environ.get('GITHUB_EVENT_NAME') == 'pull_request':
            import json
            event_data = json.loads(event_content)
            if not event_data.get('pull_request', {}).get('merged', False):
                with open(os.environ['GITHUB_OUTPUT'], 'a') as gh_out:
                    gh_out.write('should_release=false\n')
                exit(0)

            title = event_data.get('pull_request', {}).get('title', '')
            body = event_data.get('pull_request', {}).get('body', '')

            # Check for version keywords in title and body
            content = f'{title} {body}'.lower()

            # Major version keywords
            major_keywords = ['breaking change', 'breaking', 'major', '!feat', '!fix']
            # Minor version keywords
            minor_keywords = ['feat:', 'feature:', 'minor', 'enhancement']
            # Patch version keywords
            patch_keywords = ['fix:', 'bugfix:', 'patch:', 'hotfix:', 'docs:', 'style:', 'refactor:', 'perf:', 'test:', 'chore:']

            version_type = 'patch'  # default

            if any(keyword in content for keyword in major_keywords):
                version_type = 'major'
            elif any(keyword in content for keyword in minor_keywords):
                version_type = 'minor'
            elif any(keyword in content for keyword in patch_keywords):
                version_type = 'patch'

            with open(os.environ['GITHUB_OUTPUT'], 'a') as gh_out:
                gh_out.write(f'version_type={version_type}\n')
                gh_out.write('should_release=true\n')
        else:
            with open(os.environ['GITHUB_OUTPUT'], 'a') as gh_out:
                gh_out.write('should_release=false\n')
        "

    - name: Get current version
      id: current-version
      run: |
        # Fetch all tags to ensure we have the latest
        git fetch --tags --force

        # Get the latest version tag (tags starting with 'v' followed by numbers)
        latest_tag=$(git tag --list "v*" --sort=-version:refname | head -n1)

        # Fallback if no version tags found
        if [ -z "$latest_tag" ]; then
          latest_tag="v0.1.0"
        fi

        echo "Debug: Found tag: ${latest_tag}"
        echo "current_version=${latest_tag#v}" >> $GITHUB_OUTPUT
        echo "Current version: ${latest_tag#v}"

    - name: Calculate new version
      id: new-version
      run: |
        python -c "
        import semver
        import os

        current = '${{ steps.current-version.outputs.current_version }}'
        version_type = '${{ steps.version-check.outputs.version_type }}'

        print(f'Debug: current={current}, version_type={version_type}')

        # Parse current version
        try:
            current_semver = semver.VersionInfo.parse(current)
            print(f'Debug: parsed current version: {current_semver}')
        except Exception as e:
            print(f'Debug: error parsing version: {e}')
            current_semver = semver.VersionInfo(0, 1, 0)

        # Bump version
        if version_type == 'major':
            new_version = current_semver.bump_major()
        elif version_type == 'minor':
            new_version = current_semver.bump_minor()
        else:
            new_version = current_semver.bump_patch()

        print(f'Debug: new version: {new_version}')
        with open(os.environ['GITHUB_OUTPUT'], 'a') as gh_out:
            gh_out.write(f'new_version={new_version}\n')
        "

    - name: Generate release notes
      id: release-notes
      run: |
        python -c "
        import os
        import json

        # Get PR information
        if os.environ.get('GITHUB_EVENT_NAME') == 'pull_request':
            event_path = os.environ.get('GITHUB_EVENT_PATH')
            if event_path and os.path.exists(event_path):
                with open(event_path, 'r') as f:
                    event_data = json.load(f)

                pr = event_data.get('pull_request', {})
                title = pr.get('title', '')
                body = pr.get('body', '')
                author = pr.get('user', {}).get('login', 'Unknown')
                number = pr.get('number', '')

                notes = f'## Release v${{ steps.new-version.outputs.new_version }}\n\n'
                notes += f'PR #{number} - {title}\n\n'
                notes += f'Author: {author}\n\n'

                if body:
                    notes += f'Description:\n{body}\n\n'

                notes += 'Changes:\n'
                notes += f'- {title}\n'

                # Write notes directly to a file
                with open('release_notes.md', 'w') as f:
                    f.write(notes)

                with open(os.environ['GITHUB_OUTPUT'], 'a') as gh_out:
                    gh_out.write('notes_file=release_notes.md\n')
            else:
                # Create a fallback release note when PR info is unavailable
                with open('release_notes.md', 'w') as f:
                    f.write('Release notes could not be generated - PR information unavailable\n')

                with open(os.environ['GITHUB_OUTPUT'], 'a') as gh_out:
                    gh_out.write('notes_file=release_notes.md\n')
        else:
            # Create a simple manual release note
            with open('release_notes.md', 'w') as f:
                f.write('Manual release\n')

            with open(os.environ['GITHUB_OUTPUT'], 'a') as gh_out:
                gh_out.write('notes_file=release_notes.md\n')
        "

    - name: Debug outputs
      run: |
        echo "Debug: Checking job outputs..."
        echo "version_type: ${{ steps.version-check.outputs.version_type }}"
        echo "current_version: ${{ steps.current-version.outputs.current_version }}"
        echo "new_version: ${{ steps.new-version.outputs.new_version }}"
        echo "should_release: ${{ steps.version-check.outputs.should_release }}"
        echo "notes_file: ${{ steps.release-notes.outputs.notes_file }}"

    - name: Upload release notes
      uses: actions/upload-artifact@v4
      with:
        name: release-notes
        path: release_notes.md

  create-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: determine-version
    if: needs.determine-version.outputs.should_release == 'true'

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Download release notes
      uses: actions/download-artifact@v4
      with:
        name: release-notes
        path: .

    - name: Create Release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: v${{ needs.determine-version.outputs.new_version }}
        release_name: Release v${{ needs.determine-version.outputs.new_version }}
        body_path: release_notes.md
        draft: false
        prerelease: false

    - name: Log version information
      run: |
        echo "âœ… Release v${{ needs.determine-version.outputs.new_version }} created successfully!"
        echo "ðŸ“ Version information:"
        echo "  - Previous version: ${{ steps.current-version.outputs.current_version }}"
        echo "  - New version: ${{ needs.determine-version.outputs.new_version }}"
        echo "  - Version type: ${{ needs.determine-version.outputs.version_type }}"

  release-summary:
    name: Release Summary
    runs-on: ubuntu-latest
    needs: [determine-version, create-release]
    if: always()

    steps:
    - name: Download release notes
      uses: actions/download-artifact@v4
      with:
        name: release-notes
        path: .
      continue-on-error: true

    - name: Release Results Summary
      run: |
        echo "## ðŸš€ Automated Release Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ“‹ Release Information" >> $GITHUB_STEP_SUMMARY
        echo "- **Version Type**: ${{ needs.determine-version.outputs.version_type }}" >> $GITHUB_STEP_SUMMARY
        echo "- **New Version**: ${{ needs.determine-version.outputs.new_version }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Release Created**: ${{ needs.create-release.result == 'success' && 'âœ… Yes' || 'âŒ No' }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ” Trigger Details" >> $GITHUB_STEP_SUMMARY
        echo "- **Event**: ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Branch**: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ“ Release Notes" >> $GITHUB_STEP_SUMMARY
        if [ -f "release_notes.md" ]; then
          cat release_notes.md >> $GITHUB_STEP_SUMMARY
        else
          echo "Release notes could not be retrieved - artifact download may have failed" >> $GITHUB_STEP_SUMMARY
        fi
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸš€ Next Steps" >> $GITHUB_STEP_SUMMARY
        if [ "${{ needs.create-release.result }}" = "success" ]; then
          echo "âœ… Release v${{ needs.determine-version.outputs.new_version }} created successfully!" >> $GITHUB_STEP_SUMMARY
          echo "- GitHub release available at: https://github.com/${{ github.repository }}/releases/tag/v${{ needs.determine-version.outputs.new_version }}" >> $GITHUB_STEP_SUMMARY
        else
                      echo "âŒ Release creation failed. Please check the logs for errors." >> $GITHUB_STEP_SUMMARY
        fi
